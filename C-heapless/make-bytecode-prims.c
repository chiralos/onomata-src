#include "parser-recursive.h"
#include "optimiser.h"
#include <string.h> 
#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h> // for exit()

typedef struct Def {
  char *name;       
  char *src;
} Def;

// THIS MUST BE KEPT IN Opcode ORDER

Def defs[] = {
  { "loopBytecode", "dup dip swp (loop) (pop) ife" },
  { "writeLineBytecode", 
    "\"\\n\" str/cat stdout swp write pop" },
  { "loadonceBytecode",
    "dup \"-loaded\" str/cat dup is-defined"
    "(pop pop) ((true) def load) ife" },
  { "loadBytecode", // load
      "read-only open dup 0 lt"
      "(pop \"open error\" write-line)"
      "(dup (\"\" 1 3 pack () swp load-fd) dip close pop)"
      "ife" },
  { "loadfdBytecode",
      "dup 0 tup/get 0 lt not"
      "( dup 0 tup/get swp dup 1 tup/get swp"
      "  ( dup len 192 swp sub swp (read-str) dip"
      "    swp (swp str/cat) dip"
      "  ) dip"
      "  swp dup 0 lt"
      "  (pop pop pop \"read error\" write-line false)"
      "  ((swp 1 tup/set) dip 0 eq (-1 0 tup/set) () ife true)"
      "  ife"
      ") (true) ife"
      "( dup 2 tup/get swp dup 1 tup/get swp "
      "  (parse-part) dip swp dup 1 lt"
      "  ( pop swp 1 tup/set swp dup (2 tup/set) dip"
      "    1 eq (swp dip () swp) () ife true)"
      "  ((pop pop) dip errstr write-line false)" // see [1]
      "  ife"
      ") (false) ife"
      "( dup 1 tup/get len 0 eq swp dup 0 tup/get 0 lt swu and"
      "  ( dup 2 tup/get 1 gt"
      "    (\"incomplete parse\" write-line) () ife true"
      "  ) (false) ife not"
      ") (false) ife"
      "(load-fd) (pop pop) ife" },
  { "loadstrBytecode",
      "str -1 swp 1 3 pack () swp load-fd" },
  { "saveBytecode",
      "write-only trunc bit/or creat bit/or open "
      "dup 0 lt"
      "(pop \"open error\" write-line)"
      "(dup (save-fd) dip close pop)"
      "ife" },
  { "replBytecode",
      "( stdin term/reset pop"
      "  stdout \"ono> \" write pop"
      "  stdin 96 read-str 1 lt (pop false) (true) ife"
      "  (load-str write-stack true) (false) ife"
      ") loop" },
  { "defmemBytecode", "alloc-static quo def" }
};

const int ndefs = sizeof(defs)/sizeof(Def);

#define BUFSIZE 1024
Byte parseBuf[BUFSIZE];
Byte optBuf[BUFSIZE];

Env env;

int main(int argc, char** argv) {
  Seg in;
  Seg out;
  printf("// bytecode-prim-table.c\n");
  printf("// generated by make-bytecode-prims\n\n");
  printf("#include \"bytecode.h\"\n\n");
  for (int i=0;i < ndefs;i++) {
    in.cursor  = (Code)defs[i].src;
    in.end     = in.cursor + strlen((char *)in.cursor);
    out.cursor = parseBuf;
    out.end    = out.cursor + BUFSIZE;

    Err err = parseSeq(&in,&out,0);
    if (err) {
      printf("source error: %d\n",err);
      exit(err);
    }

    in.cursor  = parseBuf;
    in.end     = out.cursor;
    out.cursor = optBuf;
    out.end    = out.cursor + BUFSIZE;
    if ((env.err = setjmp(env.catch)) == 0) {
      err = peepholeOptimise(&in,&out);
    } else {
      if (env.err == ERR_UNKNOWN_SYMBOL)
        printf("unknown symbol %s\n", env.errWord);
    }

    if (err) {
      printf("optimiser error: %d\n",err);
      exit(env.err);
    }
    
    int sz = out.cursor - optBuf;
    printf("unsigned char %s[%d] = {",defs[i].name,sz);
    for (int j=0;j < sz;j++) {
      if (j % 16 == 0) printf("\n  ");
      printf("%3d,",optBuf[j]);
    }
    printf(" };\n");
  }
  printf("\n");
  printf("const BytecodeRef bytecodePrimTable[%d] = {",ndefs);
  for (int i=0;i < ndefs;i++) 
    printf("\n  { %1$s, %1$s + sizeof(%1$s) },", defs[i].name);
  printf(" };\n\n");
  return 0;
}

////////
// Notes
/*
[1] We could clean up further by popping any nested procs:
    (2 get 1 add pop-n) instead of (pop pop)

    pop-n <-> (pop) swp repeat
    repeat <-> 1 sub dup 0 gte ((dup dip) dip repeat) (pop pop) ife

But the extra procs give a hint to where the parse when wrong.
*/
